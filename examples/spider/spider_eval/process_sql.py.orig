import os
from pathlib import Path
import json
import sqlite3
from typing import List, Dict, Tuple, Any

# Constants
TIMEOUT_SECONDS = 30  # Timeout for SQL query execution


class Schema:
    """
    Simple schema which maps table&column to a unique identifier
    """
    def __init__(self, schema, db):
        self._schema = schema
        self._db = db
        # Connect in read-only mode to prevent accidental or malicious modifications.
        db_file = Path(db)
        db_uri = f"{db_file.as_uri()}?mode=ro"
        self.conn = sqlite3.connect(db_uri, uri=True, timeout=TIMEOUT_SECONDS)
        self.conn.text_factory = str
        self.c = self.conn.cursor()

    @property
    def schema(self):
        return self._schema

    @property
    def idMap(self):
        return self._schema.idMap

    def __repr__(self):
        return self._schema.__repr__()


def get_schema(db, db_path="database"):
    """Get database schema."""
    # Connect in read-only mode to prevent accidental or malicious modifications.
    db_file = Path(os.path.join(db_path, db, db + '.sqlite'))
    db_uri = f"{db_file.as_uri()}?mode=ro"
    conn = sqlite3.connect(db_uri, uri=True, timeout=TIMEOUT_SECONDS)
    conn.text_factory = str
    cursor = conn.cursor()
    ans = cursor.execute("SELECT name, sql FROM sqlite_master WHERE type='table'").fetchall()
    conn.close()
    return ans


def is_safe_query(query: str) -> bool:
    """
    Validate that the query is a safe SELECT statement.
    Returns True if the query appears to be a SELECT statement only.
    """
    if not query or not isinstance(query, str):
        return False
    
    # Remove leading/trailing whitespace and convert to uppercase for checking
    query_upper = query.strip().upper()
    
    # Check if it starts with SELECT
    if not query_upper.startswith('SELECT'):
        return False
    
    # Check for dangerous keywords that shouldn't appear in SELECT queries
    dangerous_keywords = ['DROP', 'DELETE', 'INSERT', 'UPDATE', 'ALTER', 'CREATE', 'TRUNCATE', 'REPLACE']
    for keyword in dangerous_keywords:
        if keyword in query_upper:
            return False
    
    return True


def result_eq(db, db_name, p_str, g_str):
    """
    return 1 if the values between prediction and gold are matching
    in the corresponding database
    """
    # Connect in read-only mode to prevent accidental or malicious modifications.
    db_file = Path(os.path.join(db, db_name, db_name + ".sqlite"))
    db_uri = f"{db_file.as_uri()}?mode=ro"
    conn = sqlite3.connect(db_uri, uri=True, timeout=TIMEOUT_SECONDS)
    conn.text_factory = str
    cursor = conn.cursor()
    
    try:
        # Validate queries before execution
        if not is_safe_query(p_str):
            print(f"Warning: Predicted query failed safety validation: {p_str}")
            return 0
        
        if not is_safe_query(g_str):
            print(f"Warning: Gold query failed safety validation: {g_str}")
            return 0
        
        # Execute queries with proper error handling
        p_res = cursor.execute(p_str).fetchall()
        g_res = cursor.execute(g_str).fetchall()
        
        # Compare results
        return int(set(p_res) == set(g_res))
    except sqlite3.Error as e:
        print(f"SQL execution error: {e}")
        return 0
    except Exception as e:
        print(f"Unexpected error during query execution: {e}")
        return 0
    finally:
        conn.close()
